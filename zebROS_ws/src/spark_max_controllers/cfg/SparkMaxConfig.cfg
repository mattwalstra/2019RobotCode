#!/usr/bin/env python

PACKAGE= 'spark_max_controllers'

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()
#       Name                        Type        Reconfiguration-level   Description                         Default Min Max
gen.add("inverted",                 bool_t,     0,                      "Motor inverted or not",            False)
gen.add("p0",                       double_t,   0,                      "Proportional constant 0",          0,      0,  100)
gen.add("i0",                       double_t,   0,                      "Integral constant 0",              0,      0,  100)
gen.add("d0",                       double_t,   0,                      "Derivative constant 0",            0,      0,  100)
gen.add("f0",                       double_t,   0,                      "Feed forward constant 0",          0,      0,  100)
gen.add("izone0",                   double_t,   0,                      "Limits integral error: range 0",   0,      0,  100000)
gen.add("dfilter0"                  double_t,   0,                      "Weight to d term 0",               0,      0,  1)
gen.add("pidfoutputmin0",           double_t,   0,                      "Minimum output 0",                 -1,     -100000, 0)
gen.add("pidfoutputmax0",           double_t,   0,                      "Maximum output 0",                 1,      0,  100000)
pidf_reference_ctrl = gen.enum([ gen.const("kDutyCycle", int_t, 0, ""), 
                                 gen.const("kPosition", int_t, 1, ""), 
                                 gen.const("kVelocity", int_t, 2, ""), 
                                 gen.const("kVoltage", int_t, 3, "")
                                 ], "")
gen.add("pidfreferencectrl0",     int_t,      0,                      "Reference Control type setting 0", 0,      0,  3, edit_method=pidf_reference_ctrl)
gen.add("pidfarbfeedforward0",   double_t,   0,                      "Arbitrary FeedForward Voltage 0",  0,      0,  100000)

gen.add("p1",                       double_t,   0,                      "Proportional constant 1",          0,      0,  100)
gen.add("i1",                       double_t,   0,                      "Integral constant 1",              0,      0,  100)
gen.add("d1",                       double_t,   0,                      "Derivative constant 1",            0,      0,  100)
gen.add("f1",                       double_t,   0,                      "Feed forward constant 1",          0,      0,  100)
gen.add("izone1",                   double_t,   0,                      "Limits integral error: range 1",   0,      0,  100000)
gen.add("dfilter1"                  double_t,   0,                      "Weight to d term 1",               0,      0,  1)
gen.add("pidfoutputmin1",           double_t,   0,                      "Minimum output 1",                 -1,     -100000, 0)
gen.add("pidfoutputmax1",           double_t,   0,                      "Maximum output 1",                 1,      0,  100000)
gen.add("pidf_reference_ctrl1",     int_t,      0,                      "Reference Control type setting 1", 0,      0,  3, edit_method=pidf_reference_ctrl)
gen.add("pidf_arb_feed_forward1",   double_t,   0,                      "Arbitrary FeedForward Voltage 1",  0,      0,  100000)

gen.add("p2",                       double_t,   0,                      "Proportional constant 2",          0,      0,  100)
gen.add("i2",                       double_t,   0,                      "Integral constant 2",              0,      0,  100)
gen.add("d2",                       double_t,   0,                      "Derivative constant 2",            0,      0,  100)
gen.add("f2",                       double_t,   0,                      "Feed forward constant 2",          0,      0,  100)
gen.add("izone2",                   double_t,   0,                      "Limits integral error: range 2",   0,      0,  100000)
gen.add("dfilter2"                  double_t,   0,                      "Weight to d term 2",               0,      0,  1)
gen.add("pidfoutputmin2",           double_t,   0,                      "Minimum output 2",                 -1,     -100000, 0)
gen.add("pidfoutputmax2",           double_t,   0,                      "Maximum output 2",                 1,      0,  100000)
gen.add("pidf_reference_ctrl2",     int_t,      0,                      "Reference Control type setting 2", 0,      0,  3, edit_method=pidf_reference_ctrl)
gen.add("pidf_arb_feed_forward2",   double_t,   0,                      "Arbitrary FeedForward Voltage 2",  0,      0,  100000)

gen.add("p3",                       double_t,   0,                      "Proportional constant 3",          0,      0,  100)
gen.add("i3",                       double_t,   0,                      "Integral constant 3",              0,      0,  100)
gen.add("d3",                       double_t,   0,                      "Derivative constant 3",            0,      0,  100)
gen.add("f3",                       double_t,   0,                      "Feed forward constant 3",          0,      0,  100)
gen.add("izone3",                   double_t,   0,                      "Limits integral error: range 3",   0,      0,  100000)
gen.add("dfilter3"                  double_t,   0,                      "Weight to d term 3",               0,      0,  1)
gen.add("pidfoutputmin3",           double_t,   0,                      "Minimum output 3",                 -1,     -100000, 0)
gen.add("pidfoutputmax3",           double_t,   0,                      "Maximum output 3",                 1,      0,  100000)
gen.add("pidf_reference_ctrl3",     int_t,      0,                      "Reference Control type setting 3", 0,      0,  3, edit_method=pidf_reference_ctrl)
gen.add("pidf_arb_feed_forward3",   double_t,   0,                      "Arbitrary FeedForward Voltage 3",  0,      0,  100000)

gen.add("pidfslot",                 int_t,      0,                      "Reference Control Slot",           0,      0,  3)

limit_switch_polarity = gen.enum([ gen.const("kNormallyOpen",     int_t,  0,  ""),
                                 gen.const("kNormallyClosed",   int_t,  1,  ""),
                            ], "")
gen.add("forwardlimitswitchpolarity", int_t,     0,                      "Forward Limit Switch Polarity",    0,      0,  1, edit_method=limit_switch_polarity)
gen.add("forwardlimitswitchenabled", bool_t,    0,                      "Forward Limit Switch Enabled",     False)

gen.add("reverselimitswitchpolarity", int_t,     0,                      "Reverse Limit Switch Polarity",    0,      0,  1, edit_method=limit_switch_polarity)
gen.add("reverselimitswitchenabled", bool_t,    0,                      "Reverse Limit Switch Enabled",     False)

gen.add("currentlimit",             double_t,   0,                      "Current Limit",                    0,      0,  100000)
gen.add("currentlimitstall",        double_t,   0,                      "Current Limit Stall",              0,      0,  100000)
gen.add("currentlimitfree",         double_t,   0,                      "Current Limit Free",               0,      0,  100000)
gen.add("currentlimitrpm",          double_t,   0,                      "Current Limit RPM",                0,      0,  100000)

gen.add("secondarycurrentlimit",    double_t,   0,                      "Secondary Current Limit",          0,      0,  100000)
gen.add("secondarycurrentlimitcycles", double_t,   0,                   "Secondary Current Limit Cycles",   0,      0,  100000)

idle_mode = gen.enum([ gen.const("kCoast",  int_t, 0, ""),
                       gen.const("kBrake",  int_t, 1, ""),
                    ], "")

gen.add("idlemode",                 int_t,      0,                      "Idle Mode",                        0,      0,  1,  edit_method=idle_mode)
gen.add("ramprate",                 double_t,   0,                      "Close and Open loop ramp rate",    0,      0,  100000)

exit(gen.generate(PACKAGE, "talon_reconfigure_node", "TalonConfig"))